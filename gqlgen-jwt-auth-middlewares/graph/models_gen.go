// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

type Address struct {
	CountryCode string `json:"countryCode"`
	Country     string `json:"country"`
}

type AssignOffChainNftsInput struct {
	NftID  int `json:"nftId"`
	Amount int `json:"amount"`
	UserID int `json:"userId"`
}

type AssociateAddressEnd struct {
	SignedMessage string `json:"signedMessage"`
}

type AssociateAddressInitialize struct {
	Address string `json:"address"`
}

type Attribute struct {
	DisplayType *string `json:"displayType"`
	TraitType   *string `json:"traitType"`
	Value       *string `json:"value"`
}

type AttributeInput struct {
	DisplayType *string `json:"displayType"`
	TraitType   *string `json:"traitType"`
	Value       *string `json:"value"`
}

type Authentication struct {
	Jwt  string `json:"jwt"`
	User *User  `json:"user"`
}

type AuthorizationBatch struct {
	TokenContract string `json:"tokenContract"`
	Ids           []int  `json:"ids"`
	Amounts       []int  `json:"amounts"`
	ValidUntil    int    `json:"validUntil"`
}

type AuthorizationBatchResponse struct {
	Signature     *Signature          `json:"signature"`
	Authorization *AuthorizationBatch `json:"authorization"`
}

type AuthorizationBuy struct {
	TokenContract string `json:"tokenContract"`
	Seller        string `json:"seller"`
	ID            int    `json:"id"`
	Amount        int    `json:"amount"`
	ToSeller      string `json:"toSeller"`
	Total         string `json:"total"`
	ValidUntil    int    `json:"validUntil"`
}

type AuthorizationBuyResponse struct {
	Signature     *Signature        `json:"signature"`
	Authorization *AuthorizationBuy `json:"authorization"`
}

type AuthorizationTransfer struct {
	TokenContract string `json:"tokenContract"`
	ID            int    `json:"id"`
	Amount        int    `json:"amount"`
	ValidUntil    int    `json:"validUntil"`
}

type AuthorizationTransferResponse struct {
	Signature     *Signature             `json:"signature"`
	Authorization *AuthorizationTransfer `json:"authorization"`
}

type BankAccount struct {
	Country           string `json:"country"`
	AccountHolderName string `json:"accountHolderName"`
	AccountHolderType string `json:"accountHolderType"`
	Currency          string `json:"currency"`
	RoutingNumber     string `json:"routingNumber"`
	Status            string `json:"status"`
	Last4             string `json:"last4"`
}

type BankAccountRequirements struct {
	Currencies []*Currency `json:"currencies"`
}

type BlogPost struct {
	ID           int       `json:"id"`
	Title        string    `json:"title"`
	Body         string    `json:"body"`
	Image        *string   `json:"image"`
	CreationTime time.Time `json:"CreationTime"`
}

type BlogPostsFilter struct {
	Contains   *string           `json:"contains"`
	OrderBy    *BlogPostsOrderBy `json:"orderBy"`
	Pagination *Pagination       `json:"pagination"`
}

type BlogPostsOrderBy struct {
	CreationTime *OrderDirection `json:"creationTime"`
}

type BuyInput struct {
	NftID       int    `json:"nftID"`
	Amount      int    `json:"amount"`
	StripeToken string `json:"stripeToken"`
}

type Category struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type ConfirmEmailInput struct {
	Key string `json:"key"`
}

type CreateBatchTransferAuthorizationInput struct {
	Ids     []int `json:"ids"`
	Amounts []int `json:"amounts"`
}

type CreateBlogPostInput struct {
	Title string         `json:"title"`
	Body  string         `json:"body"`
	Image graphql.Upload `json:"image"`
}

type CreateBuyAuthorizationInput struct {
	ID     int `json:"id"`
	Amount int `json:"amount"`
}

type CreateCardInput struct {
	Name     string `json:"name"`
	Number   string `json:"number"`
	ExpMonth string `json:"expMonth"`
	ExpYear  string `json:"expYear"`
	Cvc      string `json:"cvc"`
}

type CreateIPFSHashInput struct {
	//  Metadata
	Name        string            `json:"name"`
	Description string            `json:"description"`
	ExternalURL *string           `json:"externalUrl"`
	Attributes  []*AttributeInput `json:"attributes"`
	//  Files
	Image     graphql.Upload  `json:"image"`
	Animation *graphql.Upload `json:"animation"`
}

type CreatePaymentIntentInput struct {
	NftID  int `json:"nftID"`
	Amount int `json:"amount"`
}

type CreateStripeAccountLinkInput struct {
	ReturnURL  string `json:"returnUrl"`
	RefreshURL string `json:"refreshUrl"`
}

type CreateStripeCheckoutLinkInput struct {
	CancelURL  string `json:"cancelUrl"`
	SuccessURL string `json:"successUrl"`
	NftID      int    `json:"nftId"`
	Amount     int    `json:"amount"`
}

type CreateStripeCheckoutResponse struct {
	StripeCheckoutLink string `json:"stripeCheckoutLink"`
	PaymentIntentID    string `json:"paymentIntentId"`
}

type CreateTransferAuthorizationInput struct {
	ID     int `json:"id"`
	Amount int `json:"amount"`
}

type CreateUserInput struct {
	Email           string `json:"email"`
	Password        string `json:"password"`
	FirstName       string `json:"firstName"`
	LastName        string `json:"lastName"`
	PreferredName   string `json:"preferredName"`
	ApplyAsDesigner bool   `json:"applyAsDesigner"`
	//  ISO 3166-1 alpha-2
	Country string `json:"country"`
}

type Currency struct {
	Code      string   `json:"code"`
	Countries []string `json:"countries"`
}

type DeleteBlogPostInput struct {
	ID int `json:"id"`
}

type DesignedFieldFilter struct {
	OnSale *bool `json:"onSale"`
}

type DesignerApplication struct {
	UserID     int       `json:"userId"`
	User       *User     `json:"user"`
	SubmitTime time.Time `json:"submitTime"`
}

type DesignerApplicationsFilter struct {
	User       *DesignerApplicationsUsersFilter `json:"user"`
	OrderBy    *DesignerApplicationsOrderBy     `json:"orderBy"`
	Pagination *Pagination                      `json:"pagination"`
}

type DesignerApplicationsOrderBy struct {
	ID            *OrderDirection `json:"id"`
	PreferredName *OrderDirection `json:"preferredName"`
	LastName      *OrderDirection `json:"lastName"`
	SubmitTime    *OrderDirection `json:"submitTime"`
}

type DesignerApplicationsUsersFilter struct {
	ID    *int    `json:"id"`
	Name  *string `json:"name"`
	Email *string `json:"email"`
}

type ForgotPasswordEnd struct {
	NewPassword string `json:"newPassword"`
	Key         string `json:"key"`
}

type ForgotPasswordInitialize struct {
	Email string `json:"email"`
}

type FromTo struct {
	Address string `json:"address"`
	User    *User  `json:"user"`
}

type FulfillPaymentIntentInput struct {
	ID     string `json:"id"`
	Cancel *bool  `json:"cancel"`
}

type InitialCategoryInput struct {
	NftID      int `json:"nftId"`
	CategoryID int `json:"categoryId"`
}

type LoginBlockchainEndInput struct {
	Message       string `json:"message"`
	SignedMessage string `json:"signedMessage"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Nft struct {
	ID            int          `json:"id"`
	TotalSupply   int          `json:"totalSupply"`
	Creator       string       `json:"creator"`
	CreatorUser   *User        `json:"creatorUser"`
	BlockCreation int          `json:"blockCreation"`
	Transfers     []*Transfer  `json:"transfers"`
	Owners        []*Owner     `json:"owners"`
	Categories    []*Category  `json:"categories"`
	Sale          *Sale        `json:"sale"`
	FilterURL     *string      `json:"filterUrl"`
	Owned         *UserHasNfts `json:"owned"`
	//  Metadata
	Name         string       `json:"name"`
	Description  string       `json:"description"`
	ExternalURL  string       `json:"externalUrl"`
	Image        string       `json:"image"`
	AnimationURL string       `json:"animationUrl"`
	Attributes   []*Attribute `json:"attributes"`
}

type NftsFilter struct {
	Ids         []int        `json:"ids"`
	CategoryIds []int        `json:"categoryIds"`
	OrderBy     *NftsOrderBy `json:"orderBy"`
	Name        *string      `json:"name"`
	Pagination  *Pagination  `json:"pagination"`
	OnSale      *bool        `json:"onSale"`
}

type NftsOrderBy struct {
	ID   *OrderDirection `json:"id"`
	Name *OrderDirection `json:"name"`
}

type OffchainNft struct {
	ID     int `json:"id"`
	Amount int `json:"amount"`
}

type Owner struct {
	User      *User    `json:"user"`
	Addresses []string `json:"addresses"`
	Amount    int      `json:"amount"`
}

type Pagination struct {
	Limit int `json:"limit"`
	Page  int `json:"page"`
}

type PaymentIntent struct {
	ID           string `json:"id"`
	ClientSecret string `json:"clientSecret"`
}

type Profile struct {
	Image       *string `json:"image"`
	Description *string `json:"description"`
}

type ProfileInput struct {
	Image       *graphql.Upload `json:"image"`
	Description *string         `json:"description"`
}

type ResendConfirmationEmailInput struct {
	Email *string `json:"email"`
}

type ResolveDesignerApplicationInput struct {
	ID      int  `json:"id"`
	Approve bool `json:"approve"`
}

type Response struct {
	Success *bool   `json:"success"`
	Message *string `json:"message"`
}

type Role struct {
	ID    int     `json:"id"`
	Name  string  `json:"name"`
	Users []*User `json:"users"`
}

type RolesFilter struct {
	ID   *int             `json:"id"`
	Name *string          `json:"name"`
	User *RolesUserFilter `json:"user"`
}

type RolesUserFilter struct {
	ID *int `json:"id"`
}

type Sale struct {
	NftID       *int     `json:"nftId"`
	Eth         float64  `json:"eth"`
	Usd         *float64 `json:"usd"`
	AcceptsFiat bool     `json:"acceptsFiat"`
	Available   int      `json:"available"`
}

type SaveCreationIntentInput struct {
	ID          string  `json:"id"`
	FilterURL   *string `json:"filterUrl"`
	CategoryID  int     `json:"categoryId"`
	EthPrice    float64 `json:"ethPrice"`
	AcceptsFiat bool    `json:"acceptsFiat"`
}

type SaveFilter struct {
	NftID     int    `json:"nftId"`
	FilterURL string `json:"filterUrl"`
}

type SendEventInput struct {
	EventType              EventType       `json:"eventType"`
	SearchString           *string         `json:"searchString"`
	ContentID              *string         `json:"contentId"`
	ContentName            *string         `json:"contentName"`
	ContentCategory        *string         `json:"contentCategory"`
	Currency               *string         `json:"currency"`
	Value                  *float64        `json:"value"`
	NumItems               *int            `json:"numItems"`
	PaymentIntentID        *string         `json:"paymentIntentId"`
	AuthorizationSignature *SignatureInput `json:"authorizationSignature"`
	GaClientID             *string         `json:"gaClientId"`
}

type SendSuccessfulBuyEmailInput struct {
	NftID  int    `json:"nftID"`
	TxHash string `json:"txHash"`
}

type SetRoleInput struct {
	UserID   int  `json:"userId"`
	RoleID   int  `json:"roleId"`
	Activate bool `json:"activate"`
}

type Signature struct {
	R string `json:"r"`
	S string `json:"s"`
	V string `json:"v"`
}

type SignatureInput struct {
	R string `json:"r"`
	S string `json:"s"`
	V string `json:"v"`
}

type SubscriptionInput struct {
	Email              string `json:"email"`
	SubscriptionTypeID int    `json:"subscriptionTypeId"`
}

type SubscriptionsFilter struct {
	ID   *int                     `json:"id"`
	Name *string                  `json:"name"`
	User *SubscriptionsUserFilter `json:"user"`
}

type SubscriptionsUserFilter struct {
	ID *int `json:"id"`
}

type ToggleCategory struct {
	NftID      int `json:"nftId"`
	CategoryID int `json:"categoryId"`
}

type Transfer struct {
	ID     string  `json:"id"`
	From   *FromTo `json:"from"`
	To     *FromTo `json:"to"`
	Amount int     `json:"amount"`
	Block  int     `json:"block"`
	Nft    *Nft    `json:"nft"`
}

type UnsubscribeInput struct {
	Email              string `json:"email"`
	SubscriptionTypeID int    `json:"subscriptionTypeId"`
	Signature          string `json:"signature"`
}

type UpsertPayoutTokenInput struct {
	Token string `json:"token"`
}

type UpsertSaleInput struct {
	NftID       int     `json:"nftId"`
	EthPrice    float64 `json:"ethPrice"`
	AcceptsFiat bool    `json:"acceptsFiat"`
}

type User struct {
	ID            int            `json:"id"`
	FirstName     string         `json:"firstName"`
	LastName      string         `json:"lastName"`
	Email         string         `json:"email"`
	PreferredName string         `json:"preferredName"`
	Addresses     []string       `json:"addresses"`
	Owned         []*UserHasNfts `json:"owned"`
	Designed      []*Nft         `json:"designed"`
	Roles         []*Role        `json:"roles"`
	Profile       *Profile       `json:"profile"`
	Address       *Address       `json:"address"`
	//  Relevant fields for designers
	HasCompleteProfile             bool   `json:"hasCompleteProfile"`
	HasBankAccount                 bool   `json:"hasBankAccount"`
	HasUploadedOneNft              bool   `json:"hasUploadedOneNft"`
	StripeTransferCapabilityStatus string `json:"stripeTransferCapabilityStatus"`
}

type UserHasNfts struct {
	Address  string `json:"address"`
	Nft      *Nft   `json:"nft"`
	OnChain  int    `json:"onChain"`
	OffChain int    `json:"offChain"`
}

type UserSubscription struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type UsersFilter struct {
	Ids                                  []int         `json:"ids"`
	Name                                 *string       `json:"name"`
	Email                                *string       `json:"email"`
	OrderBy                              *UsersOrderBy `json:"orderBy"`
	Pagination                           *Pagination   `json:"pagination"`
	Roles                                []int         `json:"roles"`
	HasCompleteProfile                   *bool         `json:"hasCompleteProfile"`
	HasBankAccount                       *bool         `json:"hasBankAccount"`
	HasUploadedOneNft                    *bool         `json:"hasUploadedOneNft"`
	StripeTransferCapabilityStatusActive *bool         `json:"stripeTransferCapabilityStatusActive"`
	Confirmed                            *bool         `json:"confirmed"`
}

type UsersOrderBy struct {
	ID            *OrderDirection `json:"id"`
	PreferredName *OrderDirection `json:"preferredName"`
	LastName      *OrderDirection `json:"lastName"`
}

type UsersResult struct {
	Users []*User `json:"users"`
	Count int     `json:"count"`
}

type EventType string

const (
	EventTypeSearch               EventType = "SEARCH"
	EventTypeCompleteRegistration EventType = "COMPLETE_REGISTRATION"
	EventTypeInitiateCheckout     EventType = "INITIATE_CHECKOUT"
	EventTypeAddToCart            EventType = "ADD_TO_CART"
	EventTypeAddPaymentInfo       EventType = "ADD_PAYMENT_INFO"
	EventTypeViewContent          EventType = "VIEW_CONTENT"
	EventTypeContact              EventType = "CONTACT"
	EventTypePurchase             EventType = "PURCHASE"
)

var AllEventType = []EventType{
	EventTypeSearch,
	EventTypeCompleteRegistration,
	EventTypeInitiateCheckout,
	EventTypeAddToCart,
	EventTypeAddPaymentInfo,
	EventTypeViewContent,
	EventTypeContact,
	EventTypePurchase,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeSearch, EventTypeCompleteRegistration, EventTypeInitiateCheckout, EventTypeAddToCart, EventTypeAddPaymentInfo, EventTypeViewContent, EventTypeContact, EventTypePurchase:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProtectedRule string

const (
	ProtectedRuleAdmin ProtectedRule = "ADMIN"
)

var AllProtectedRule = []ProtectedRule{
	ProtectedRuleAdmin,
}

func (e ProtectedRule) IsValid() bool {
	switch e {
	case ProtectedRuleAdmin:
		return true
	}
	return false
}

func (e ProtectedRule) String() string {
	return string(e)
}

func (e *ProtectedRule) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtectedRule(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PROTECTED_RULE", str)
	}
	return nil
}

func (e ProtectedRule) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Rule string

const (
	RuleAdminRole    Rule = "ADMIN_ROLE"
	RuleDesignerRole Rule = "DESIGNER_ROLE"
	RuleUserRole     Rule = "USER_ROLE"
	RuleDesignerOf   Rule = "DESIGNER_OF"
	RuleOwnerOf      Rule = "OWNER_OF"
)

var AllRule = []Rule{
	RuleAdminRole,
	RuleDesignerRole,
	RuleUserRole,
	RuleDesignerOf,
	RuleOwnerOf,
}

func (e Rule) IsValid() bool {
	switch e {
	case RuleAdminRole, RuleDesignerRole, RuleUserRole, RuleDesignerOf, RuleOwnerOf:
		return true
	}
	return false
}

func (e Rule) String() string {
	return string(e)
}

func (e *Rule) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Rule(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RULE", str)
	}
	return nil
}

func (e Rule) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
